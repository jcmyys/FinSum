<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¦¬ë°¸ëŸ°ì‹± ì°¨íŠ¸ (Rebalancing)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; padding: 20px; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        .container { width: 100%; max-width: 1200px; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); position: relative; }
        
        .controls { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef; }
        
        .input-group { display: flex; align-items: center; gap: 6px; }
        .input-group label { font-size: 14px; font-weight: bold; color: #555; }
        
        input[type="text"], input[type="number"] { padding: 8px; border: 1px solid #ced4da; border-radius: 4px; font-size: 14px; }
        input:focus { outline: none; border-color: #80bdff; box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25); }
        
        .symbol-input { width: 120px; text-transform: uppercase; }
        .number-input { width: 80px; }

        button.add-btn { padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background 0.15s; }
        button.add-btn:hover { background: #0056b3; }

        .symbol-list { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px; }
        .tag { 
            padding: 8px 16px; border-radius: 20px; display: flex; align-items: center; gap: 8px; font-size: 14px; 
            font-weight: 500; cursor: pointer; transition: all 0.2s; border: 1px solid #dee2e6;
            background: #e9ecef; color: #495057;
        }
        .tag.active { background: #e7f1ff; color: #0d6efd; border-color: #0d6efd; font-weight: bold; }
        .tag:hover { transform: translateY(-2px); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .tag span.remove { cursor: pointer; color: #dc3545; font-weight: bold; padding: 0 4px; z-index: 2; margin-left: 4px; }
        .tag span.remove:hover { color: #a71d2a; }

        .chart-container { position: relative; height: 65vh; width: 100%; }
        #statusMessage { text-align: center; margin-bottom: 10px; font-size: 14px; height: 20px; }

        .nav-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #f1f3f5; padding-bottom: 10px; }
        .nav-buttons { display: flex; gap: 8px; }
        
        .nav-btn { 
            padding: 8px 16px; color: white; border: none; border-radius: 6px; 
            cursor: pointer; font-size: 14px; text-decoration: none; transition: background 0.2s;
        }
        .home-btn { background: #6c757d; }
        .home-btn:hover { background: #5a6268; }

        /* ì»¤ìŠ¤í…€ íˆ´íŒ ìŠ¤íƒ€ì¼ */
        #chartjs-tooltip {
            opacity: 0;
            position: absolute;
            pointer-events: none;
            transition: all .1s ease;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            z-index: 100;
            text-align: center;
            white-space: nowrap; /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="nav-header">
            <h2 style="margin:0;">âš–ï¸ ë¦¬ë°¸ëŸ°ì‹± ì°¨íŠ¸</h2>
            <div class="nav-buttons">
                <button class="nav-btn home-btn" onclick="window.location.href='index.html'">ğŸ  ë©”ì¸ìœ¼ë¡œ</button>
            </div>
        </div>
        
        <div class="controls">
            <div class="input-group">
                <input type="text" id="symbolInput" class="symbol-input" placeholder="ì¢…ëª© (ì˜ˆ: TQQQ)" onkeypress="handleEnter(event)">
                <button class="add-btn" onclick="addSymbol()">ì¶”ê°€</button>
            </div>
            <div style="width: 1px; height: 24px; background: #ddd; margin: 0 5px;"></div>
            <div class="input-group">
                <label for="dropRate">ğŸ“‰ í•˜ë½í­(%):</label>
                <input type="number" id="dropRate" class="number-input" placeholder="2.5" step="0.1" oninput="updateChartSettings()">
            </div>
            <div class="input-group">
                <label for="basePrice">ğŸš© ê¸°ì¤€ê°€($):</label>
                <input type="number" id="basePrice" class="number-input" placeholder="ìµœê³ ê°€" step="any" oninput="updateChartSettings()">
                <button class="nav-btn" style="background: #adb5bd; padding: 6px 10px; font-size: 12px; border-radius: 4px;" onclick="resetBasePrice()">ìë™(Max)</button>
            </div>
        </div>

        <p style="font-size: 0.9em; color: #666; margin-top:-10px; margin-bottom: 20px;">
            * ê° ì¢…ëª©ë³„ë¡œ ì„¤ì •í•œ <b>ê¸°ì¤€ê°€</b>ì™€ <b>í•˜ë½í­</b>ì´ ìë™ìœ¼ë¡œ ì €ì¥ë©ë‹ˆë‹¤.
        </p>

        <div class="symbol-list" id="symbolList"></div>
        <div id="statusMessage"></div>

        <div class="chart-container">
            <canvas id="mainChart"></canvas>
            <div id="chartjs-tooltip"></div>
        </div>
    </div>

    <script>
        let myChart = null;
        let symbols = []; 
        let currentSymbol = null;
        let currentData = null;
        const STORAGE_KEY = 'rebalancing_portfolio_v1';

        let configDropRate = 2.5;
        let configBasePrice = null;

        window.onload = function() {
            loadSymbols();
            if (symbols.length === 0) {
                symbols = [
                    { symbol: 'NVDA', basePrice: null, dropRate: 2.5 },
                    { symbol: 'TQQQ', basePrice: null, dropRate: 5.0 },
                    { symbol: 'SOXL', basePrice: null, dropRate: 10.0 }
                ];
                saveSymbols();
            }
            if (symbols.length > 0) {
                selectSymbol(symbols[0].symbol); 
            } else {
                renderTags();
            }
        };

        function loadSymbols() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (parsed.length > 0 && typeof parsed[0] === 'string') {
                        symbols = parsed.map(s => ({ symbol: s, basePrice: null, dropRate: 2.5 }));
                    } else {
                        symbols = parsed;
                    }
                } catch(e) { symbols = []; }
            }
        }

        function saveSymbols() { localStorage.setItem(STORAGE_KEY, JSON.stringify(symbols)); }
        function handleEnter(e) { if (e.key === 'Enter') addSymbol(); }

        function addSymbol() {
            const input = document.getElementById('symbolInput');
            const val = input.value.trim().toUpperCase();
            if (!val) return;
            if (symbols.some(s => s.symbol === val)) {
                showMessage('âš ï¸ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¢…ëª©ì…ë‹ˆë‹¤.', 'orange');
                selectSymbol(val);
                input.value = '';
                return;
            }
            symbols.push({ symbol: val, basePrice: null, dropRate: 2.5 });
            saveSymbols();
            input.value = '';
            selectSymbol(val);
        }

        function removeSymbol(e, sym) {
            e.stopPropagation();
            symbols = symbols.filter(s => s.symbol !== sym);
            saveSymbols();
            if (currentSymbol === sym) {
                if (symbols.length > 0) selectSymbol(symbols[0].symbol);
                else {
                    currentSymbol = null;
                    destroyChart();
                    renderTags();
                    document.getElementById('dropRate').value = 2.5;
                    document.getElementById('basePrice').value = '';
                }
            } else {
                renderTags();
            }
        }

        function selectSymbol(sym) {
            currentSymbol = sym;
            const target = symbols.find(s => s.symbol === sym);
            if (target) {
                configDropRate = target.dropRate !== undefined ? target.dropRate : 2.5;
                configBasePrice = target.basePrice !== undefined ? target.basePrice : null;
                document.getElementById('dropRate').value = configDropRate;
                document.getElementById('basePrice').value = configBasePrice !== null ? configBasePrice : '';
            }
            renderTags();
            loadAndRenderChart(sym);
        }

        function renderTags() {
            const container = document.getElementById('symbolList');
            container.innerHTML = '';
            symbols.forEach(item => {
                const div = document.createElement('div');
                div.className = `tag ${item.symbol === currentSymbol ? 'active' : ''}`;
                div.onclick = () => selectSymbol(item.symbol);
                div.innerHTML = `${item.symbol} <span class="remove" onclick="removeSymbol(event, '${item.symbol}')">Ã—</span>`;
                container.appendChild(div);
            });
        }

        function showMessage(msg, color='black') {
            const el = document.getElementById('statusMessage');
            el.style.color = color;
            el.innerText = msg;
        }

        function updateChartSettings() {
            const dropInput = document.getElementById('dropRate').value;
            const priceInput = document.getElementById('basePrice').value;
            configDropRate = parseFloat(dropInput);
            if (isNaN(configDropRate)) configDropRate = 2.5;
            configBasePrice = priceInput ? parseFloat(priceInput) : null;
            if (currentSymbol) {
                const target = symbols.find(s => s.symbol === currentSymbol);
                if (target) {
                    target.dropRate = configDropRate;
                    target.basePrice = configBasePrice;
                    saveSymbols();
                }
            }
            if (myChart) myChart.update();
        }

        function resetBasePrice() {
            document.getElementById('basePrice').value = '';
            updateChartSettings();
        }

        async function loadAndRenderChart(symbol) {
            showMessage(`â³ ${symbol} ë°ì´í„° ë¡œë”© ì¤‘...`, '#0d6efd');
            const dtEnd = Math.floor(Date.now() / 1000);
            const dtStart = dtEnd - (180 * 24 * 60 * 60);
            const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${dtStart}&period2=${dtEnd}&interval=1d`;
            const url = 'https://corsproxy.io/?' + encodeURIComponent(yahooUrl);

            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error('Network Error');
                const json = await res.json();
                const result = json.chart.result[0];
                const timestamps = result.timestamp;
                const quotes = result.indicators.quote[0];
                const validLabels = [];
                const validPrices = [];
                timestamps.forEach((t, i) => {
                    if (quotes.close[i]) {
                        validLabels.push(new Date(t * 1000).toISOString().slice(0, 10));
                        validPrices.push(quotes.close[i]);
                    }
                });
                currentData = { labels: validLabels, prices: validPrices, symbol: symbol };
                drawChart();
                showMessage('âœ… ì—…ë°ì´íŠ¸ ì™„ë£Œ', 'green');
                setTimeout(() => showMessage(''), 2000);
            } catch (e) {
                console.error(e);
                showMessage(`âŒ ${symbol} ë¡œë“œ ì‹¤íŒ¨`, 'red');
            }
        }

        // í”ŒëŸ¬ê·¸ì¸ ìˆ˜ì •: ì˜¤ë¥¸ìª½ ì—¬ë°±ê¹Œì§€ ì„  ê·¸ë¦¬ê¸°
        const horizontalLinesPlugin = {
            id: 'horizontalLines',
            afterDatasetsDraw(chart, args, options) {
                // width ì†ì„± ì¶”ê°€ë¡œ ê°€ì ¸ì˜´
                const { ctx, chartArea: { top, bottom, left, right }, scales: { y }, width } = chart;
                
                if (!currentData || currentData.prices.length === 0) return;

                const maxPrice = Math.max(...currentData.prices);
                const base = configBasePrice !== null ? configBasePrice : maxPrice;
                const minVisiblePrice = y.min;
                const rate = configDropRate; 
                if (rate <= 0) return;

                ctx.save();
                ctx.textAlign = 'right';
                ctx.textBaseline = 'bottom';
                ctx.font = '12px Arial';

                let currentLevel = base;
                let dropCount = 0;
                
                // ì˜¤ë¥¸ìª½ ì—¬ë°±ì„ ê³ ë ¤í•œ ì„ ì˜ ë ì§€ì  ê³„ì‚° (ìº”ë²„ìŠ¤ ì „ì²´ ë„ˆë¹„ - ì•½ê°„ì˜ ì—¬ë°±)
                const lineEndX = width - 5;

                while (true) {
                    const price = base * (1 - (rate * dropCount) / 100);
                    if (price < minVisiblePrice * 0.85) break;

                    const yPos = y.getPixelForValue(price);

                    if (yPos >= top - 10 && yPos <= bottom + 10) {
                        ctx.beginPath();
                        ctx.lineWidth = 1;
                        if (dropCount === 0) {
                            ctx.strokeStyle = '#dc3545';
                            ctx.setLineDash([]);
                        } else {
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                            ctx.setLineDash([4, 4]);
                        }
                        
                        ctx.moveTo(left, yPos);
                        // right ëŒ€ì‹  lineEndX ì‚¬ìš©
                        ctx.lineTo(lineEndX, yPos);
                        ctx.stroke();

                        ctx.fillStyle = dropCount === 0 ? '#dc3545' : '#555';
                        let labelText = '';
                        if (dropCount === 0) labelText = `ê¸°ì¤€: $${price.toFixed(2)}`;
                        else labelText = `-${(rate * dropCount).toFixed(1)}% ($${price.toFixed(2)})`;
                        
                        // í…ìŠ¤íŠ¸ ìœ„ì¹˜ë„ lineEndX ê¸°ì¤€ìœ¼ë¡œ ë³€ê²½
                        ctx.fillText(labelText, lineEndX - 5, yPos - 3);
                    }
                    dropCount++;
                    if (dropCount > 50) break;
                }
                ctx.restore();
            }
        };

        function drawChart() {
            if (!currentData) return;
            const ctx = document.getElementById('mainChart').getContext('2d');
            const tooltipEl = document.getElementById('chartjs-tooltip');
            
            if (myChart) myChart.destroy();

            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: currentData.labels,
                    datasets: [{
                        label: currentData.symbol,
                        data: currentData.prices,
                        borderColor: '#0d6efd',
                        backgroundColor: '#0d6efd',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 5,
                        tension: 0.1,
                        fill: false
                    }]
                },
                plugins: [horizontalLinesPlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    // ì˜¤ë¥¸ìª½ ì—¬ë°± ì¶”ê°€ (padding.right: 70) ë° ìƒí•˜ ì—¬ë°± ì•½ê°„ ì¶”ê°€
                    layout: {
                        padding: {
                            right: 70,
                            top: 20,
                            bottom: 10
                        }
                    },
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: false,
                            external: function(context) {
                                const tooltipModel = context.tooltip;
                                if (tooltipModel.opacity === 0) {
                                    tooltipEl.style.opacity = 0;
                                    return;
                                }

                                // íˆ´íŒ ë‚´ìš© ì„¤ì •
                                if (tooltipModel.body) {
                                    const title = tooltipModel.title || [];
                                    const rawPrice = context.chart.data.datasets[0].data[tooltipModel.dataPoints[0].dataIndex];
                                    tooltipEl.innerHTML = `
                                        <div>${title[0]}</div>
                                        <div style="font-size:1.3em;">$${Number(rawPrice).toFixed(2)}</div>
                                    `;
                                }

                                const position = context.chart.canvas.getBoundingClientRect();
                                const tooltipWidth = tooltipEl.offsetWidth;
                                const tooltipHeight = tooltipEl.offsetHeight;

                                tooltipEl.style.opacity = 1;
                                
                                // ìˆ˜í‰ ìœ„ì¹˜: ë§ˆìš°ìŠ¤ í¬ì¸í„°(caretX)ê°€ íˆ´íŒì˜ ì¤‘ì•™ì— ì˜¤ë„ë¡ ì •ë ¬
                                const leftPos = position.left + window.pageXOffset + tooltipModel.caretX - (tooltipWidth / 2);
                                tooltipEl.style.left = leftPos + 'px';
                                
                                // ìˆ˜ì§ ìœ„ì¹˜: ë°ì´í„° í¬ì¸íŠ¸(caretY)ì—ì„œ íˆ´íŒ ë†’ì´ë§Œí¼ ìœ„ë¡œ ì˜¬ë¦¬ê³ , 15px ì¶”ê°€ ê°„ê²© ë‘ 
                                // ì´ë ‡ê²Œ í•˜ë©´ íˆ´íŒì˜ í•˜ë‹¨ì´ í•­ìƒ ë°ì´í„° í¬ì¸íŠ¸ ìœ„ì— ìœ„ì¹˜í•¨
                                const topPos = position.top + window.pageYOffset + tooltipModel.caretY - tooltipHeight - 15;
                                tooltipEl.style.top = topPos + 'px';
                            }
                        }
                    },
                    scales: {
                        y: { grid: { display: false } },
                        x: { grid: { display: false }, ticks: { maxTicksLimit: 8 } }
                    }
                }
            });
        }
        
        function destroyChart() {
            if (myChart) myChart.destroy();
            myChart = null;
            currentData = null;
        }
    </script>
</body>
</html>